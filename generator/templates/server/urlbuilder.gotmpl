{{ define "queryparambuilder" }}
{{ if not .IsArray }}{{ template "simplequeryparambuilder" . }}{{ else }}{{ template "slicequeryparambuilder" . }}{{ end }}
{{- end }}
{{ define "simplequeryparambuilder" }}
{{ if .IsNullable -}}
var {{ varname .ID }} string
if {{ .ReceiverName }}.{{ pascalize .ID }} != nil {
  {{ varname .ID }} = {{ if .Formatter }}{{ .Formatter }}(*{{ .ReceiverName }}.{{ pascalize .ID }}){{ else }}{{ if not .IsCustomFormatter }}*{{ end }}{{ .ReceiverName }}.{{ pascalize .ID }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}
}
{{ else }}{{ varname .ID }} := {{ if .Formatter }}{{ .Formatter }}({{ .ReceiverName }}.{{ pascalize .ID }}){{ else }}{{ .ReceiverName }}.{{ pascalize .ID }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}
{{ end -}}
if {{ varname .ID }} != "" {
  qs.Set({{ printf "%q" .Name }}, {{ varname .ID }})
}
{{ end }}
{{ define "sliceitemqueryparambuilder" }}
{{ if .IsNullable -}}
var {{ .ValueExpression }}S string
if {{ .ValueExpression }} != nil {
  {{ .ValueExpression }}S = {{ if .Formatter }}{{ .Formatter }}(*{{ .ValueExpression }}){{ else }}*{{ .ValueExpression }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}
}
{{ else -}}
{{ .ValueExpression }}S := {{ if .Formatter }}{{ .Formatter }}({{ .ValueExpression }}){{ else }}{{ .ValueExpression }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}
{{ end -}}
if {{ .ValueExpression }}S != "" {
  {{ .ValueExpression }}R = append({{ .ValueExpression }}R, {{ .ValueExpression }}S)
}
{{ end }}
{{define "slicequeryparambuilder" }}
var {{ .Child.ValueExpression }}R []string
for _, {{ .Child.ValueExpression }} := range {{ .ValueExpression }} {
  {{- if not .Child.IsArray }}{{ template "sliceitemqueryparambuilder" .Child }}{{ else }}{{ template "slicequeryparambuilder" .Child }}{{ end -}}
}

{{ if not .Child.Parent -}}
{{ varname .ID }} := swag.JoinByFormat({{ .Child.ValueExpression }}R, {{ printf "%q" .CollectionFormat }})
{{ if eq .CollectionFormat "multi" }}
for _, qsv := range {{ varname .ID }} {
  qs.Add({{ printf "%q" .Name }}, qsv)
}
{{ else }}
if len({{ varname .ID }}) > 0 {
  qsv := {{ varname .ID }}[0]
  if qsv != "" {
    qs.Set({{ printf "%q" .Name }}, qsv)
  }
}
{{ end }}
{{ else -}}
{{ .ValueExpression }}S := swag.JoinByFormat({{ .Child.ValueExpression }}R, {{ printf "%q" .CollectionFormat }})
if len({{ .ValueExpression }}S) > 0 {
  {{ .ValueExpression }}Ss := {{ .ValueExpression }}S[0]
  if {{ .ValueExpression }}Ss != "" {
    {{ .ValueExpression }}R = append({{ .ValueExpression }}R, {{ .ValueExpression }}Ss)
  }
}
{{ end -}}
{{ end -}}
package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
  "net/url"
  "strings"
  "fmt"
  "errors"
)

// {{ pascalize .Name }}URL generates an URL for the {{ humanize .Name }} operation
type {{ pascalize .Name }}URL struct {
  {{ range .PathParams }}
  {{ pascalize .ID }} {{.GoType}}
  {{- end }}
  {{ range .QueryParams }}
  {{ pascalize .ID }} {{ if and (not .IsArray) .IsNullable }}*{{ end }}{{.GoType}}
  {{- end }}

  {{ if or (gt (len .PathParams ) 0) (gt (len .QueryParams) 0) -}}
  // avoid unkeyed usage
  _ struct{}
  {{- end }}

}

// Build a url path and query string
func ({{ .ReceiverName }} *{{ pascalize .Name }}URL) Build() (*url.URL, error) {
  var result url.URL

  var path = {{ printf "%q" .Path }}
  {{ range .PathParams }}
  {{ varname .ID }} := {{ if .Formatter }}{{ .Formatter }}({{ .ReceiverName }}.{{ pascalize .ID }}){{ else }}{{ .ReceiverName }}.{{ pascalize .ID }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}
  if {{ varname .ID }} != "" {
    path = strings.Replace(path, "{{ printf "{%s}" .Name }}", {{ varname .ID }}, -1)
  } else {
    return nil, errors.New("{{ pascalize .ID }} is required on {{ pascalize $.Name }}URL")
  }

  {{- end }}
  result.Path = path

  {{ if gt (len .QueryParams) 0 -}}
  qs := make(url.Values)
  {{ range .QueryParams }}
  {{ template "queryparambuilder" . -}}
  {{- end }}
  result.RawQuery = qs.Encode()
  {{- end }}

  return &result, nil
}

// Must is a helper function to panic when the url builder returns an error
func ({{ .ReceiverName }} *{{ pascalize .Name }}URL) Must(u *url.URL, err error) *url.URL {
  if err != nil {
    panic(err)
  }
  if u == nil {
    panic("url can't be nil")
  }
  return u
}

// String returns the string representation of the path with query string
func ({{ .ReceiverName }} *{{ pascalize .Name }}URL) String() string {
  return {{ .ReceiverName }}.Must({{ .ReceiverName }}.Build()).String()
}

// BuildFull builds a full url with scheme, host, path and query string
func ({{ .ReceiverName }} *{{ pascalize .Name }}URL) BuildFull(scheme, host string) (*url.URL, error) {
  if scheme == "" {
    return nil, errors.New("scheme is required for a full url on {{ pascalize .Name }}URL")
  }
  if host == "" {
    return nil, errors.New("host is required for a full url on {{ pascalize .Name }}URL")
  }

  base, err := {{ .ReceiverName }}.Build()
  if err != nil {
    return nil, err
  }

  base.Scheme = scheme
  base.Host = host
  return base, nil
}

// StringFull returns the string representation of a complete url
func ({{ .ReceiverName }} *{{ pascalize .Name }}URL) StringFull(scheme, host string) string {
  return {{ .ReceiverName }}.Must( {{ .ReceiverName }}.BuildFull(scheme, host)).String()
}
