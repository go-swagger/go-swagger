{{ define "sliceparamvalidator"}}
{{ if or .MinItems .MaxItems }}
    {{ camelize .Name }}Size := int64(len({{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ if and .Child (not (hasPrefix .ValueExpression "o.")) }}{{ .Child.ValueExpression }}C{{ else }}{{ .ValueExpression }}{{ end }}))
{{ end }}
{{ if .MinItems }}
// {{ .ItemsDepth }}minItems: {{ .MinItems }}
if err := validate.MinItems({{ .Path }}, {{ printf "%q" .Location }}, {{ camelize .Name }}Size, {{ .MinItems }}); err != nil {
  return err
}
{{ end }}
{{ if .MaxItems }}
// {{ .ItemsDepth }}maxItems: {{ .MaxItems }}
if err := validate.MaxItems({{ .Path }}, {{ printf "%q" .Location }}, {{ camelize .Name }}Size, {{.MaxItems}}); err != nil {
  return err
}
{{ end }}
{{ if .UniqueItems }}
// {{ .ItemsDepth }}uniqueItems: true
if err := validate.UniqueItems({{ .Path }}, {{ printf "%q" .Location }}, {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ if and .Child (not ( hasPrefix .ValueExpression "o." )) }}{{ .Child.ValueExpression }}C{{ else }}{{ .ValueExpression }}{{ end }}); err != nil {
  return err
}
{{ end }}
{{ if .Enum }}
// {{ .ItemsDepth }}Enum: {{ .Enum }}
if err := validate.Enum({{ .Path }}, {{ printf "%q" .Location }}, {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ if and .Child (not ( hasPrefix .ValueExpression "o." )) }}{{ .Child.ValueExpression }}C{{ else }}{{ .ValueExpression }}{{ end }}); err != nil {
  return err
}
{{ end }}
{{ end }}
{{ define "propertyparamvalidator" }}
{{ if .IsPrimitive }}{{ template "validationPrimitive" . }}{{ end }}
{{ if .IsCustomFormatter }}
if err := validate.FormatOf({{.Path}}, "{{.Location}}", "{{.SwaggerFormat}}", {{ .ValueExpression}}.String(), formats); err != nil {
  return err
}{{ end }}
{{ if .IsArray }}{{ template "sliceparamvalidator" . }}{{ end -}}
{{ end }}
{{define "bindprimitiveparam" }}
{{ end }}
{{ define "sliceparambinder" }}
var {{ varname .Child.ValueExpression }}R {{ .GoType }}
for {{ if or .Child.HasValidations .Child.Converter .Child.IsCustomFormatter }}{{ .IndexVar }}{{ else }}_{{ end }}, {{ varname .Child.ValueExpression }}V := range {{ varname .Child.ValueExpression }}C {
  {{ if or .Child.IsArray -}}{{- /* Recursive resolution of arrays in params */ -}}
  // {{ .Child.ItemsDepth }}CollectionFormat: {{ .Child.CollectionFormat }}
  {{ .Child.Child.ValueExpression }}C := swag.SplitByFormat({{ varname .Child.ValueExpression }}V, {{ printf "%q" .Child.CollectionFormat }})
  if len({{ varname .Child.Child.ValueExpression }}C) > 0 {
  {{ template "sliceparambinder" .Child }}
  {{ varname .Child.ValueExpression }}R = append({{ varname .Child.ValueExpression }}R, {{ varname .Child.ValueExpression }}{{ if .Child.IsArray }}IR{{end}})
  }
  {{ if .Child.HasSliceValidations -}}{{ template "sliceparamvalidator" .Child }}{{- end -}}
  {{- else -}}{{- /* Non-array type in items */ -}}
  {{ if .Child.Converter -}}
      {{ if ne .Child.SwaggerFormat "" }}// {{ .Child.ItemsDepth }}Format: {{ printf "%q" .Child.SwaggerFormat }}{{ end }}
  {{ varname .Child.ValueExpression }}, err := {{ .Child.Converter }}({{ varname .Child.ValueExpression }}V)
  if err != nil {
    return errors.InvalidType({{ .Child.Path }}, {{ printf "%q" .Child.Location }}, "{{ .Child.GoType }}", {{ varname .Child.ValueExpression }})
  }
  {{- else if .Child.IsCustomFormatter -}}
  // {{ .Child.ItemsDepth }}Format: {{ printf "%q" .Child.SwaggerFormat }}
  value, err := formats.Parse({{ printf "%q" .Child.SwaggerFormat }},{{ varname .Child.ValueExpression }}V)
  if err != nil {
    return errors.InvalidType({{ .Child.Path }}, {{ printf "%q" .Child.Location }}, "{{ .Child.GoType }}", value)
  }
  {{ varname .Child.ValueExpression }} := *(value.(*{{.Child.GoType}}))
  {{- else -}}
  {{ varname .Child.ValueExpression }} := {{ varname .Child.ValueExpression }}V
  {{ end }}

  {{ template "propertyparamvalidator" .Child }}
  {{ varname .Child.ValueExpression }}R = append({{ varname .Child.ValueExpression }}R, {{ varname .Child.ValueExpression }}{{ if .Child.IsArray }}IR{{end}})
  {{- end }}
}
{{ end }}// Code generated by go-swagger; DO NOT EDIT.


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}


package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "net/http"

  "github.com/go-openapi/errors"
  "github.com/go-openapi/validate"
  "github.com/go-openapi/runtime"
  "github.com/go-openapi/runtime/security"
  "github.com/go-openapi/runtime/middleware"
  "github.com/go-openapi/swag"

  strfmt "github.com/go-openapi/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// New{{ pascalize .Name }}Params creates a new {{ pascalize .Name }}Params object
{{ if .Params.HasSomeDefaults -}}
// with the default values initialized.{{ else -}}
// no default values defined in spec.
{{- end }}
func New{{ pascalize .Name }}Params() {{ pascalize .Name }}Params {
{{ if .Params.HasSomeDefaults }}
  var (
  // initialize parameters with default values
  {{ range .Params }} 
      {{ if .HasDefault -}}
          {{ if not .IsFileParam }}{{ varname .ID}}Default = 
              {{- if and .IsPrimitive .IsCustomFormatter (not (stringContains .Zero "(\"" )) }}{{ .Zero }}{{/* strfmt type initializer requires UnmarshalText(), e.g. Date, Datetime, Duration */}}
              {{- else if and .IsPrimitive .IsCustomFormatter (stringContains .Zero "(\"" ) }}{{.GoType}}({{- printf "%#v" .Default }}){{/* strfmt type initializer takes string */}}
              {{- else if and .IsPrimitive (not .IsCustomFormatter) -}}{{.GoType}}({{- printf "%#v" .Default }}){{/* regular go primitive type initializer */}}
              {{- else if .IsArray -}}{{- /* Do not initialize from possible defaults in nested arrays */ -}}
                  {{- if and .Child.IsPrimitive .Child.IsCustomFormatter }}{{ .Zero }}{{/* initialization strategy with UnmarshalText() */}}
                  {{- else if .Child.IsArray -}}{{ .Zero }}{{/* initialization strategy with json.Unmarshal() */}}
                  {{- else if and .Child.IsPrimitive (not .Child.IsCustomFormatter) -}}{{.GoType}}{{- goSliceInitializer .Default }}{{/* regular go primitive type initializer: simple slice initializer */}}
                  {{- else }}{{ printf "%#v" .Default }}{{/* all other cases (e.g. schema) [should not occur] */}}
                  {{- end }}
              {{- else }}{{ printf "%#v" .Default }}{{/* case .Schema */}}
              {{- end }}
          {{- end }}
      {{- end }}
  {{- end }}
  )

{{ range .Params }}{{ if .HasDefault -}}{{- /* carry on UnmarshalText initialization strategy */ -}}
      {{ if and .IsPrimitive .IsCustomFormatter (not (stringContains .Zero "(\"")) }}{{ varname .ID}}Default.UnmarshalText([]byte({{ printf "%q" .Default }}))
      {{ else if .IsArray -}}
          {{ if or ( and .Child.IsPrimitive .Child.IsCustomFormatter ) .Child.IsArray -}}
          if err := json.Unmarshal([]byte(`{{printf "%s" (json .Default)}}`), &{{ varname .ID }}Default); err != nil {
            // panics if specification is invalid
            msg := fmt.Sprintf("invalid default value for parameter {{ varname .ID }}: %v",err)
            panic(msg)
          }
          {{ end -}}
      {{- end }}
  {{ end -}}
{{- end }} 
{{ end }}
  return {{ pascalize .Name }}Params{ {{ range .Params }}{{ if .HasDefault }}
    {{ pascalize .ID}}: {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}&{{ end }}{{ varname .ID }}Default,
  {{ end }}{{ end }} }
}

// {{ pascalize .Name }}Params contains all the bound params for the {{ humanize .Name }} operation
// typically these are obtained from a http.Request
//
// swagger:parameters {{ .Name }}
type {{ pascalize .Name }}Params struct {

  // HTTP Request Object
  HTTPRequest *http.Request `json:"-"`

  {{ range .Params }}/*{{ if .Description }}{{ blockcomment .Description }}{{ end }}{{ if .Required }}
  Required: true{{ end }}{{ if .Maximum }}
  Maximum: {{ if .ExclusiveMaximum }}< {{ end }}{{ .Maximum }}{{ end }}{{ if .Minimum }}
  Minimum: {{ if .ExclusiveMinimum }}> {{ end }}{{ .Minimum }}{{ end }}{{ if .MultipleOf }}
  Multiple Of: {{ .MultipleOf }}{{ end }}{{ if .MaxLength }}
  Max Length: {{ .MaxLength }}{{ end }}{{ if .MinLength }}
  Min Length: {{ .MinLength }}{{ end }}{{ if .Pattern }}
  Pattern: {{ .Pattern }}{{ end }}{{ if .MaxItems }}
  Max Items: {{ .MaxItems }}{{ end }}{{ if .MinItems }}
  Min Items: {{ .MinItems }}{{ end }}{{ if .UniqueItems }}
  Unique: true{{ end }}{{ if .Location }}
  In: {{ .Location }}{{ end }}{{ if .CollectionFormat }}
  Collection Format: {{ .CollectionFormat }}{{ end }}{{ if .HasDefault }}
  Default: {{ printf "%#v" .Default }}{{ end }}
  */
  {{ if not .Schema }}{{ pascalize .ID }} {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{.GoType}}{{ else }}{{ pascalize .Name }} {{ if and (not .Schema.IsBaseType) .IsNullable (not .Schema.IsStream) }}*{{ end }}{{.GoType}}{{ end }}
  {{ end}}
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with New{{ pascalize .Name }}Params() beforehand.
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
  var res []error

  {{ .ReceiverName }}.HTTPRequest = r

  {{ if .HasQueryParams }}qs := runtime.Values(r.URL.Query()){{ end }}

  {{ if .HasFormParams }}if err := r.ParseMultipartForm(32 << 20); err != nil {
		if err != http.ErrNotMultipart {
            return err
        } else if err := r.ParseForm(); err != nil {
            return err
        }
	}{{ if .HasFormValueParams }}
  fds := runtime.Values(r.Form)
  {{ end }}{{ end }}

  {{ range .Params }}
  {{ if not .IsArray -}}
  {{ if .IsQueryParam }}q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, _ := qs.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsPathParam }}r{{ pascalize .Name }}, rhk{{ pascalize .Name }}, _ := route.Params.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(r{{ pascalize .Name }}, rhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsHeaderParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(r.Header[http.CanonicalHeaderKey({{ .Path }})], true, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsFormParam -}}
    {{if .IsFileParam }}{{ camelize .Name }}, {{ camelize .Name }}Header, err := r.FormFile({{ .Path }})
  if err != nil {{ if .IsNullable }}&& err != http.ErrMissingFile{{ end }}{
    res = append(res, errors.New(400, "reading file %q failed: %v", {{ printf "%q" (camelize .Name) }}, err))
        {{ if .IsNullable }}} else if err == http.ErrMissingFile {
    // no-op for missing but optional file parameter
        {{ end }}} else if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}({{ camelize .Name }}, {{ camelize .Name }}Header); err != nil {
    {{ if .Required }}// Required: true{{ printf "\n" }}{{end }}res = append(res, err)
  } else {
    {{ .ReceiverName }}.{{ pascalize .Name }} = &runtime.File{Data: {{ camelize .Name }}, Header: {{ camelize .Name }}Header}
  }
    {{ else }}fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, _ := fds.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
    {{ end }}{{/* end .FileParam */}} 
  {{ end }}{{/* end not .Array */}}
  {{ else if .IsArray -}}
    {{ if .IsQueryParam }}q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, _ := qs.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(q{{ pascalize .Name }}, qhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsPathParam }}r{{ pascalize .Name }}, rhk{{ pascalize .Name }}, _ := route.Params.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(r{{ pascalize .Name }}, rhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsHeaderParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(r.Header[http.CanonicalHeaderKey({{ .Path }})], true, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if and .IsFormParam }}fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, _ := fds.GetOK({{ .Path }})
  if err := {{ .ReceiverName }}.bind{{ pascalize .ID }}(fd{{ pascalize .Name }}, fdhk{{ pascalize .Name }}, route.Formats); err != nil {
    res = append(res, err)
  }
  {{ end }}{{ end }}

  {{ if and .IsBodyParam .Schema }}if runtime.HasBody(r) {
  {{ if .Schema.IsStream }}{{ .ReceiverName }}.{{ pascalize .Name }} = r.Body
  {{ else }}defer r.Body.Close()
  {{ if and .Schema.IsBaseType .Schema.IsExported }}body, err := {{ .ModelsPackage }}.Unmarshal{{ stripPackage .GoType .ModelsPackage }}{{ if .IsArray }}Slice{{ end }}(r.Body, route.Consumer)
  if err != nil { {{ if .Required }}
    if err == io.EOF {
      err = errors.Required({{ .Path }}, {{ printf "%q" .Location }})
    }
    {{ end }}res = append(res, err)
  {{ else }}var body {{ .GoType }}
  if err := route.Consumer.Consume(r.Body, &body); err != nil { {{ if .Required }}
    if err == io.EOF {
      res = append(res, errors.Required({{ printf "%q" (camelize .Name) }}, {{ printf "%q" .Location }}))
    } else { {{ end }}
    res = append(res, errors.NewParseError({{ printf "%q" (camelize .Name) }}, {{ printf "%q" .Location }}, "", err)){{ if .Required }}
    }
    {{ end }}
  {{ end }}} else {
    {{ if .IsArray }}{{ if .Child }}{{ if (and (not .Child.IsInterface) (or .Child.IsAliased .Child.IsComplexObject)) }}for _, {{ .IndexVar }}{{ .ReceiverName }} := range body {
      if err := {{ .IndexVar }}{{ .ReceiverName }}.Validate(route.Formats); err != nil {
        res = append(res, err)
        break
      }
    }
    {{ end }}{{ end }}{{ else if (and (not .Schema.IsInterface) (or .Schema.IsAliased .Schema.IsComplexObject)) }}if err := body.Validate(route.Formats); err != nil {
      res = append(res, err)
    }
    {{ end }}
    if len(res) == 0 {
      {{ .ReceiverName }}.{{ pascalize .Name }} = {{ if and (not .Schema.IsBaseType) .IsNullable }}&{{ end }}body
    }
  }
  {{ end }}
  }{{ if .Required }} else {
    res = append(res, errors.Required({{ printf "%q" (camelize .Name) }}, {{ printf "%q" .Location }}))
  }  {{ end }}

  {{ end }}
  {{ end }}
  if len(res) > 0 {
    return errors.CompositeValidationError(res...)
  }
  return nil
}

{{ $className := (pascalize .Name) }}
{{ range .Params }}
{{ if .IsFileParam }}
func ({{ .ReceiverName }} *{{ $className }}Params) bind{{ pascalize .ID }}(file multipart.File, header *multipart.FileHeader) error {
  {{if or .MinLength .MaxLength}}size, _ := file.Seek(0, io.SeekEnd)
  file.Seek(0, io.SeekStart)
  {{end}}
  {{if .MinLength}}if size < {{.MinLength}} {
    return errors.ExceedsMinimum({{ .Path }}, {{ printf "%q" .Location }}, {{ .MinLength }}, false)
  }
  {{end}}
  {{if .MaxLength}}if size > {{.MaxLength}} {
    return errors.ExceedsMaximum({{ .Path }}, {{ printf "%q" .Location }}, {{ .MaxLength }}, false)
  }
  {{end}}
  return nil
}
{{ end }}
{{ if not (or .IsBodyParam .IsFileParam) }}
{{ if or .IsPrimitive .IsCustomFormatter }}
func ({{ .ReceiverName }} *{{ $className }}Params) bind{{ pascalize .ID }}(rawData []string, hasKey bool, formats strfmt.Registry) error {
  {{ if and (not .IsPathParam) .Required }}if !hasKey {
    return errors.Required({{ .Path }}, {{ printf "%q" .Location }})
  }
  {{ end }}var raw string
  if len(rawData) > 0 {
    raw = rawData[len(rawData)-1]
  }

  // Required: {{ .Required }}
  {{ if .IsQueryParam }}// AllowEmptyValue: {{ .AllowEmptyValue }}{{ end }}{{ if .IsPathParam }}// Parameter is provided by construction from the route{{ end }}
  {{ if and (not .IsPathParam) .Required (not .AllowEmptyValue) -}}
  if err := validate.RequiredString({{ .Path }}, {{ printf "%q" .Location }}, raw); err != nil {
    return err
  }
  {{ else if and ( not .IsPathParam ) (or (not .Required) .AllowEmptyValue) -}}
  if raw == "" { // empty values pass all other validations{{ if .HasDefault }}
    // Default values have been previously initialized by New{{ $className }}Params(){{ end }}
    return nil
  }
  {{ end }}
  {{ if .Converter }}value, err := {{ .Converter }}(raw)
  if err != nil {
    return errors.InvalidType({{ .Path }}, {{ printf "%q" .Location }}, {{ printf "%q" .GoType }}, raw)
  }
  {{ .ValueExpression }} = {{ if .IsNullable }}&{{ end }}value
  {{ else if .IsCustomFormatter }}// Format: {{ .SwaggerFormat }}
  value, err := formats.Parse({{ printf "%q" .SwaggerFormat }}, raw)
  if err != nil {
    return errors.InvalidType({{ .Path }}, {{ printf "%q" .Location }}, {{ printf "%q" .GoType }}, raw)
  }
  {{ .ValueExpression }} = {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsFileParam) (not .IsStream) (not .IsNullable) }}*{{ end }}(value.(*{{ .GoType }}))
  {{else}}{{ .ValueExpression }} = {{ if .IsNullable }}&{{ end }}raw
  {{ end }}
  {{if .HasValidations }}if err := {{ .ReceiverName }}.validate{{ pascalize .ID }}(formats); err != nil {
    return err
  }
  {{ end }}
  return nil
}
{{else if .IsArray}}
func ({{ .ReceiverName }} *{{ $className }}Params) bind{{ pascalize .ID }}(rawData []string, hasKey bool, formats strfmt.Registry) error {
  {{if .Required }}if !hasKey {
    return errors.Required({{ .Path }}, {{ printf "%q" .Location }})
  }
  {{ end }}
  {{ if eq .CollectionFormat "multi" -}}
  // CollectionFormat: {{ .CollectionFormat }}
  {{ varname .Child.ValueExpression }}C := rawData 
  {{ else -}} 
  var qv{{ pascalize .Name }} string
  if len(rawData) > 0 {
    qv{{ pascalize .Name }} = rawData[len(rawData) - 1]
  }

  // CollectionFormat: {{ .CollectionFormat }}
  {{ varname .Child.ValueExpression }}C := swag.SplitByFormat(qv{{ pascalize .Name }}, {{ printf "%q" .CollectionFormat }}){{ end }}
  {{if and .Required (not .AllowEmptyValue) }}
  if len({{ varname .Child.ValueExpression }}C) == 0 {
    return errors.Required({{ .Path }}, {{ printf "%q" .Location }})
  }
  {{ else }}if len({{ varname .Child.ValueExpression }}C) == 0 { {{ if .HasDefault }}
    // Default values have been previously initialized by New{{ $className }}Params(){{ end }}
    return nil
  }{{ end }}
  {{ template "sliceparambinder" . }}
  {{ .ValueExpression }} = {{ varname .Child.ValueExpression }}R
  {{ if .HasSliceValidations }}if err := {{ .ReceiverName }}.validate{{ pascalize .ID }}(formats); err != nil {
    return err
  }
  {{ end }}

  return nil
}
{{ end }}
{{ if or .HasValidations .HasSliceValidations }}
func ({{ .ReceiverName }} *{{ $className }}Params) validate{{ pascalize .ID }}(formats strfmt.Registry) error {
  {{ template "propertyparamvalidator" . }}
  return nil
}
{{ end }}
{{ end }}
{{ end }}
