{{ define "clientresponse" }}// New{{ pascalize .Name }} creates a {{ pascalize .Name }} with default headers values
func New{{ pascalize .Name }}({{ if eq .Code -1 }}code int{{ end }}{{ if .Schema }}{{ if and (eq .Code -1) .Schema.IsStream }}, {{end}}{{ if .Schema.IsStream }}writer io.Writer{{ end }}{{ end }}) *{{ pascalize .Name }} {
  return &{{ pascalize .Name }}{
    {{ if eq .Code -1 }}_statusCode: code,
    {{ end }}{{ range .Headers }}{{ if .HasDefault }}{{ pascalize .Name }}: {{ printf "%#v" .Default }},
    {{ end }}{{ end }}{{ if .Schema }}{{ if .Schema.IsStream }}Payload: writer,
    {{ end }}{{ end }}}
}

/*{{ pascalize .Name}} handles this case with default header values.

{{ if .Description }}{{ .Description }}{{else}}{{ pascalize .Name }} {{ humanize .Name }}{{end}}
*/
type {{ pascalize .Name }} struct {
  {{ if eq .Code -1 }}
  _statusCode int

  {{ end }}{{ range .Headers }}{{ if .Description }}/*{{ .Description }}
  */{{ end }}
  {{ pascalize .Name }} {{ .GoType }}
  {{ end }}
  {{ if .Schema }}
  Payload {{ if and (not .Schema.IsBaseType) (not .Schema.IsInterface) .Schema.IsComplexObject (not .Schema.IsStream) }}*{{ end }}{{ if (not .Schema.IsStream) }}{{ .Schema.GoType }}{{ else }}io.Writer{{end}}
  {{ end }}
}{{ if eq .Code -1 }}

// Code gets the status code for the {{ humanize .Name }} response
func ({{ .ReceiverName }} *{{ pascalize .Name }}) Code() int {
  return {{ .ReceiverName }}._statusCode
}
{{ end }}


func ({{ .ReceiverName }} *{{ pascalize .Name }}) Error() string {
	return fmt.Sprintf("[{{ upper .Method }} {{ .Path }}][%d] {{ if .Name }}{{ .Name }} {{ else }}unknown error {{ end }}{{ if .Schema }} %+v{{ end }}", {{ if eq .Code -1 }}{{ .ReceiverName }}._statusCode{{ else }}{{ .Code }}{{ end }}{{ if .Schema }}, o.Payload{{ end }})
}


func ({{ .ReceiverName }} *{{ pascalize .Name }}) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {
  {{ range .Headers }}
  // response header {{.Name}}
  {{if .Converter }}{{ camelize .Name }}, err := {{ .Converter }}(response.GetHeader("{{ .Name }}"))
  if err != nil {
    return errors.InvalidType({{ .Path }}, "header", "{{ .GoType }}", response.GetHeader("{{ .Name }}"))
  }
  {{ .ReceiverName }}.{{ pascalize .Name }} = {{ camelize .Name }}
  {{ else if .IsCustomFormatter }}
  {{ camelize .Name }}, err := formats.Parse({{ printf "%q" .SwaggerFormat }}, response.GetHeader("{{ .Name }}"))
  if err != nil {
    return errors.InvalidType({{ .Path }}, "header", "{{ .GoType }}", response.GetHeader("{{ .Name }}"))
  }
  {{ .ReceiverName }}.{{ pascalize .Name }} = *({{ camelize .Name }}.(*{{ .GoType }}))
  {{ else}}{{ .ReceiverName }}.{{ pascalize .Name }} = response.GetHeader("{{ .Name }}")
  {{end}}
  {{ end }}
  {{ if .Schema }}
  {{ if .Schema.IsBaseType }}
  // response payload as interface type
  payload, err := {{ .ModelsPackage }}.Unmarshal{{ stripPackage .Schema.GoType .ModelsPackage }}{{ if .Schema.IsArray}}Slice{{ end }}(response.Body(), consumer)
  if err != nil {
    return err
  }
  {{ .ReceiverName }}.Payload = payload
  {{ else if .Schema.IsComplexObject }}
  {{ .ReceiverName }}.Payload = new({{ .Schema.GoType }})
  {{ end }}{{ if not .Schema.IsBaseType }}
  // response payload
  if err := consumer.Consume(response.Body(), {{ if not (or .Schema.IsComplexObject .Schema.IsStream) }}&{{ end}}{{ .ReceiverName }}.Payload); err != nil && err != io.EOF {
    return err
  }
  {{ end }}{{ end }}
  return nil
}
{{ end }}package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command


import (
  "io"
  "net/http"

  "github.com/go-openapi/runtime"
  "github.com/go-openapi/swag"
  "github.com/go-openapi/errors"
  "github.com/go-openapi/validate"
  "github.com/go-openapi/runtime"

  strfmt "github.com/go-openapi/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// {{ pascalize .Name }}Reader is a Reader for the {{ pascalize .Name }} structure.
type {{ pascalize .Name }}Reader struct {
  formats strfmt.Registry{{ if .HasStreamingResponse }}
  writer  io.Writer{{ end }}
}

// ReadResponse reads a server response into the received {{ .ReceiverName }}.
func ({{ .ReceiverName }} *{{ pascalize .Name }}Reader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
  {{ if .Responses}}switch response.Code() {
  {{ end }}{{ range .Responses }}
    case {{ .Code }}:
      result := New{{ pascalize .Name }}({{ if .Schema }}{{ if .Schema.IsStream }}{{ $.ReceiverName }}.writer{{ end }}{{ end }})
      if err := result.readResponse(response, consumer, {{ $.ReceiverName }}.formats); err != nil {
        return nil, err
      }
      return {{ if .IsSuccess }}result, nil{{else}}nil, result{{end}}
  {{end}}{{ if .DefaultResponse }}{{ with .DefaultResponse }}
    {{ if $.Responses}}default:
      {{ end }}result := New{{ pascalize .Name }}(response.Code(){{ if .Schema }}{{ if .Schema.IsStream }}, {{ $.ReceiverName }}.writer{{ end }}{{ end }})
      if err := result.readResponse(response, consumer, {{ $.ReceiverName }}.formats); err != nil {
        return nil, err
      }
      if response.Code() / 100 == 2 {
        return result, nil
      }
      return nil, result{{ end }}{{else}}
    {{ if $.Responses}}default:
      {{ end }}return nil, runtime.NewAPIError("unknown error", response, response.Code()){{ end }}
  {{ if .Responses}}}{{ end }}
}

{{ range .Responses }}
{{ template "clientresponse" . }}
{{ end }}
{{ if .DefaultResponse }}
{{ template "clientresponse" .DefaultResponse }}
{{ end }}

{{ range .ExtraSchemas }}
/*{{ pascalize .Name }} {{ template "docstring" . }}
swagger:model {{ .Name }}
*/
{{ template "schema" . }}
{{ end }}
